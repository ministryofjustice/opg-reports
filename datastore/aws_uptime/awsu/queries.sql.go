// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package awsu

import (
	"context"
)

const count = `-- name: Count :one
SELECT count(*) FROM aws_uptime
`

func (q *Queries) Count(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countStmt, count)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insert = `-- name: Insert :one
INSERT INTO aws_uptime(
    ts,
    unit,
    date,
    average
) VALUES (
    ?,?,?,?
) RETURNING id
`

type InsertParams struct {
	Ts      string  `json:"ts"`
	Unit    string  `json:"unit"`
	Date    string  `json:"date"`
	Average float64 `json:"average"`
}

func (q *Queries) Insert(ctx context.Context, arg InsertParams) (int, error) {
	row := q.queryRow(ctx, q.insertStmt, insert,
		arg.Ts,
		arg.Unit,
		arg.Date,
		arg.Average,
	)
	var id int
	err := row.Scan(&id)
	return id, err
}

const oldest = `-- name: Oldest :one
;
SELECT run_date FROM aws_uptime_tracker ORDER BY run_date ASC LIMIT 1
`

func (q *Queries) Oldest(ctx context.Context) (string, error) {
	row := q.queryRow(ctx, q.oldestStmt, oldest)
	var run_date string
	err := row.Scan(&run_date)
	return run_date, err
}

const track = `-- name: Track :exec
INSERT INTO aws_uptime_tracker (run_date) VALUES(?)
`

func (q *Queries) Track(ctx context.Context, runDate string) error {
	_, err := q.exec(ctx, q.trackStmt, track, runDate)
	return err
}

const uptimePerDay = `-- name: UptimePerDay :many
SELECT
    (coalesce(SUM(average), 0) / count(*) ) as average,
    strftime("%Y-%m-%d", date) as interval
FROM aws_uptime
WHERE
    date >= ?1 AND
    date < ?2
GROUP BY strftime("%Y-%m-%d", date)
ORDER by strftime("%Y-%m-%d", date) ASC
`

type UptimePerDayParams struct {
	Start string `json:"start"`
	End   string `json:"end"`
}

type UptimePerDayRow struct {
	Average  interface{} `json:"average"`
	Interval interface{} `json:"interval"`
}

func (q *Queries) UptimePerDay(ctx context.Context, arg UptimePerDayParams) ([]UptimePerDayRow, error) {
	rows, err := q.query(ctx, q.uptimePerDayStmt, uptimePerDay, arg.Start, arg.End)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UptimePerDayRow
	for rows.Next() {
		var i UptimePerDayRow
		if err := rows.Scan(&i.Average, &i.Interval); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uptimePerDayFilterByUnit = `-- name: UptimePerDayFilterByUnit :many
SELECT
    (coalesce(SUM(average), 0) / count(*) ) as average,
    strftime("%Y-%m-%d", date) as interval,
    unit
FROM aws_uptime
WHERE
    date >= ?1 AND
    date < ?2 AND
    unit = ?3
GROUP BY strftime("%Y-%m-%d", date), unit
ORDER by strftime("%Y-%m-%d", date) ASC
`

type UptimePerDayFilterByUnitParams struct {
	Start string `json:"start"`
	End   string `json:"end"`
	Unit  string `json:"unit"`
}

type UptimePerDayFilterByUnitRow struct {
	Average  interface{} `json:"average"`
	Interval interface{} `json:"interval"`
	Unit     string      `json:"unit"`
}

func (q *Queries) UptimePerDayFilterByUnit(ctx context.Context, arg UptimePerDayFilterByUnitParams) ([]UptimePerDayFilterByUnitRow, error) {
	rows, err := q.query(ctx, q.uptimePerDayFilterByUnitStmt, uptimePerDayFilterByUnit, arg.Start, arg.End, arg.Unit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UptimePerDayFilterByUnitRow
	for rows.Next() {
		var i UptimePerDayFilterByUnitRow
		if err := rows.Scan(&i.Average, &i.Interval, &i.Unit); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uptimePerDayUnit = `-- name: UptimePerDayUnit :many
SELECT
    (coalesce(SUM(average), 0) / count(*) ) as average,
    strftime("%Y-%m-%d", date) as interval,
    unit
FROM aws_uptime
WHERE
    date >= ?1 AND
    date < ?2
GROUP BY strftime("%Y-%m-%d", date), unit
ORDER by strftime("%Y-%m-%d", date) ASC
`

type UptimePerDayUnitParams struct {
	Start string `json:"start"`
	End   string `json:"end"`
}

type UptimePerDayUnitRow struct {
	Average  interface{} `json:"average"`
	Interval interface{} `json:"interval"`
	Unit     string      `json:"unit"`
}

func (q *Queries) UptimePerDayUnit(ctx context.Context, arg UptimePerDayUnitParams) ([]UptimePerDayUnitRow, error) {
	rows, err := q.query(ctx, q.uptimePerDayUnitStmt, uptimePerDayUnit, arg.Start, arg.End)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UptimePerDayUnitRow
	for rows.Next() {
		var i UptimePerDayUnitRow
		if err := rows.Scan(&i.Average, &i.Interval, &i.Unit); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uptimePerMonth = `-- name: UptimePerMonth :many
SELECT
    (coalesce(SUM(average), 0) / count(*) ) as average,
    strftime("%Y-%m", date) as interval
FROM aws_uptime
WHERE
    date >= ?1 AND
    date < ?2
GROUP BY strftime("%Y-%m", date)
ORDER by strftime("%Y-%m", date) ASC
`

type UptimePerMonthParams struct {
	Start string `json:"start"`
	End   string `json:"end"`
}

type UptimePerMonthRow struct {
	Average  interface{} `json:"average"`
	Interval interface{} `json:"interval"`
}

func (q *Queries) UptimePerMonth(ctx context.Context, arg UptimePerMonthParams) ([]UptimePerMonthRow, error) {
	rows, err := q.query(ctx, q.uptimePerMonthStmt, uptimePerMonth, arg.Start, arg.End)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UptimePerMonthRow
	for rows.Next() {
		var i UptimePerMonthRow
		if err := rows.Scan(&i.Average, &i.Interval); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uptimePerMonthFilterByUnit = `-- name: UptimePerMonthFilterByUnit :many
SELECT
    (coalesce(SUM(average), 0) / count(*) ) as average,
    strftime("%Y-%m", date) as interval,
    unit
FROM aws_uptime
WHERE
    date >= ?1 AND
    date < ?2 AND
    unit = ?3
GROUP BY strftime("%Y-%m", date), unit
ORDER by strftime("%Y-%m", date) ASC
`

type UptimePerMonthFilterByUnitParams struct {
	Start string `json:"start"`
	End   string `json:"end"`
	Unit  string `json:"unit"`
}

type UptimePerMonthFilterByUnitRow struct {
	Average  interface{} `json:"average"`
	Interval interface{} `json:"interval"`
	Unit     string      `json:"unit"`
}

func (q *Queries) UptimePerMonthFilterByUnit(ctx context.Context, arg UptimePerMonthFilterByUnitParams) ([]UptimePerMonthFilterByUnitRow, error) {
	rows, err := q.query(ctx, q.uptimePerMonthFilterByUnitStmt, uptimePerMonthFilterByUnit, arg.Start, arg.End, arg.Unit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UptimePerMonthFilterByUnitRow
	for rows.Next() {
		var i UptimePerMonthFilterByUnitRow
		if err := rows.Scan(&i.Average, &i.Interval, &i.Unit); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uptimePerMonthUnit = `-- name: UptimePerMonthUnit :many
SELECT
    (coalesce(SUM(average), 0) / count(*) ) as average,
    strftime("%Y-%m", date) as interval,
    unit
FROM aws_uptime
WHERE
    date >= ?1 AND
    date < ?2
GROUP BY strftime("%Y-%m", date), unit
ORDER by strftime("%Y-%m", date) ASC
`

type UptimePerMonthUnitParams struct {
	Start string `json:"start"`
	End   string `json:"end"`
}

type UptimePerMonthUnitRow struct {
	Average  interface{} `json:"average"`
	Interval interface{} `json:"interval"`
	Unit     string      `json:"unit"`
}

func (q *Queries) UptimePerMonthUnit(ctx context.Context, arg UptimePerMonthUnitParams) ([]UptimePerMonthUnitRow, error) {
	rows, err := q.query(ctx, q.uptimePerMonthUnitStmt, uptimePerMonthUnit, arg.Start, arg.End)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UptimePerMonthUnitRow
	for rows.Next() {
		var i UptimePerMonthUnitRow
		if err := rows.Scan(&i.Average, &i.Interval, &i.Unit); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const youngest = `-- name: Youngest :one
SELECT run_date FROM aws_uptime_tracker ORDER BY run_date DESC LIMIT 1
`

func (q *Queries) Youngest(ctx context.Context) (string, error) {
	row := q.queryRow(ctx, q.youngestStmt, youngest)
	var run_date string
	err := row.Scan(&run_date)
	return run_date, err
}
